# 知识点梳理

## 1、语言基础

### 1.1 auto 和decltype用法

auto用于变量声明时根据初始化表达式自动推断该变量类型，在声明函数时作为函数返回值的占位符，通常和decltype配合使用。

适用场景：1、声明变量不需要指明类型；2、当类型名比较长时（比如迭代器，函数指针）；3、当变量的类型依赖于模板参数，需要编译器来推断

decltype用于推断某个表达式的数据类型。

### 1.2 智能指针

普通指针存在的问题：一块内存被多个指针引用，如果其中的一个指针释放了内存，其他指针并不知道，可能会引起挂起引用的问题；还有一种情况是，从内存中申请了内存后不释放，会发生内存泄露问题。

auto_ptr存在问题，被弃用。c++98引入的auto_ptr，主要问题在auto_ptr在转移指针所有权后会产生野指针，导致程序运行时crash。

unique_ptr是auto_ptr的继承者，对同一块内存只能有一个持有者。unique_ptr不允许赋值操作，一定程度避免了误操作导致的指针控制权转移。使用move方法可以转移指针的控制权，原有的unique_ptr失效，需要慎用move方法。unique_ptr支持创建动态数组。**这个坑最少**

shared_ptr：共享所有权的概念，多个指针可以同时指向一个对象，当最后一个shared_ptr离开作用域时，内存才会自动释放。

使用中需要注意：

1、尽量使用shared_ptr构造函数或者make_shared的方式创建shared_ptr，禁止裸指针赋值的方式，这样shared_ptr难于管理指针的生命周期。

2、禁止使用指向shared_ptr的裸指针，也就是智能指针的指针。

3、使用shared_ptr创建动态数组不推荐，**推荐使用unique_ptr**。

4、用shared_ptr实现多态。析构函数不用定义为虚函数了。

5、循环引用，A引用B，B引用A，智能指针永远大于1，程序退出后仍无法释放，需要改用weak_ptr解决。

weak_ptr：使用shared_ptr赋值给一个weak_ptr不会增加强引用计数（strong_count），取而代之的是增加一个弱引用计数（weak_ptr），而弱引用计数不会影响到指针的生命周期，解开了循环引用的症结。

weak_ptr不负责裸指针的生命周期，那么weak_ptr也无法直接操作裸指针，需要先转换成shared_ptr。

### 1.3 lamda表达式

lambda来源于函数式编程的概念，lambda表达式把函数看作对象。

一个完整的lambda表达式的组成如下：

```
[ capture-list ] ( params ) mutable(optional) exception(optional) attribute(optional) -> ret(optional) { body } 
```

除了捕获列表，Lambda 表达式的其它地方其实和普通的函数基本一样。

lambda表达式的好处在于可以就地定义目标函数或函数对象，不需要额外写一个函数名称或者函数对象；另外一个好处就是捕获列表的用法，所谓捕获就是将局部变量保存到lambda表达式内部，即lambda表达式通过捕获列表来访问外部的局部变量（这就是一种闭包行为，通俗讲子函数可以使用父函数的局部变量），这些局部变量指的是lambda表达式被调用的作用域内的局部变量。

与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。值捕获时内部会保存一份副本，引用捕获则不会。

### 1.4 右值引用

解决了C++中大量的历史遗留问题，使C++标准库的实现在多种场景下消除了不必要的额外开销。

https://toutiao.io/posts/rseuap/preview

https://zhuanlan.zhihu.com/p/107445960

通俗的讲，所谓左值可以运用&操作符获取地址，其他的都是左值。

右值引用&&和传统意义上的引用&很相似（又被称为左值引用）。

左值引用和右值引用的绑定规则：

1、非const左值引用只能绑定到非const左值

2、const左值引用可以绑定到const左值，const右值，非const右值

3、非const右值引用只能绑定到非const右值，但不适用于函数模板的形参

4、const右值引用可以绑定到const右值和非const右值，但没有现实意义。

拷贝构造、移动构造、赋值构造、移动赋值构造

c++11提供了std::move含义用于将某些左值转成右值，以匹配右值引用类型。

### 1.5 深浅拷贝

深浅拷贝主要是针对指针来讲，关键区别在于是否重新申请了一块新内存。

## 2、图像、音视频处理和编解码



## 3、大数据



## 4、深度学习

## 4.1AutoEncoder，自编码器

自编码器是一类在 半监督学习和无监督学习中使用的人工神经网络。通常包含编码器和解码器两个部分，编码器是将输入样本x映射到特征空间Z，而解码器这是从特征空间映射到原始空间，并生产重构X‘，其优化目标在于最小化重构误差。

## 4.2 代价函数与损失函数

代价函数cost function也叫损失函数loss function，用于评估模型的预测值和真实值不一样的程度，也是神经网络中优化的目标函数。

## 4.3 GAN 生成对抗网络

GAN由生成器和判别器组成，生成器负责生成样本，判别器负责判断生成器生成的样本是否为真。生成器要尽可能迷糊判别器，而判别器要尽可能区分生成器生成的样本和真实样本。

## 5、行业相关

